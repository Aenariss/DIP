<!DOCTYPE html>
<html>
<head>
    <title>Content Blocking Test</title>
    <script>
        let resources = {{ resources|tojson }};
        let total_resources = {{ n_of_resources }};
        total_resources = parseInt(total_resources);
        let loaded = 0;
        let blocked = 0;
        const BATCH_SIZE = 50;  // Limit how many are handled at once
        const TIMEOUT = 2500;  // Timeout in milliseconds (2.5 seconds)

        // Function to check if an error is related to a socket reset or similar network issues
        function isSocketError(error) {
            // Add additional checks here for socket-specific error messages or types if needed
            return error.message.includes('ERR_SOCKET_NOT_CONNECTED');
        }

        async function fetchResource(url) {
            // need to repeat multiple times because Selenium keeps crashing and is overall absolutely terrible
            const maxRetries = 1000;
            let attempt = 0;
            let success = false;


            while (attempt <= maxRetries && !success) {
                let timeoutId = 0
                try {
                    attempt++;

                    // Create an AbortController and signal for timeout
                    const controller = new AbortController();
                    const signal = controller.signal;

                    // Set timeout to abort the fetch request
                    timeoutId = setTimeout(() => controller.abort(), TIMEOUT);

                    // Perform the fetch request with the timeout signal
                    let response = await fetch(url, { mode: 'no-cors', signal });

                    // Clear the timeout if fetch is successful
                    clearTimeout(timeoutId);

                    if (response.ok || response.type === 'opaque') {
                        loaded++;
                        updateResults();  // Update results for successful load
                        success = true;
                    } else {
                        throw new Error();
                    }

                } catch (error) {
                    clearTimeout(timeoutId); // Clear the timeout in case of an error

                    if (isSocketError(error) && attempt <= maxRetries) {
                        continue;
                    } else if (error.name === 'AbortError') {
                        console.error(error)
                        updateResults();
                        break;
                    } else {
                        blocked++;
                        updateResults();  // Update results for blocked/failed request
                        break;  // Stop retrying if it's not a socket error or timeout
                    }
                }
            }
        }

        // Async generator that yields batches of URLs
        async function* batchGenerator(array, batchSize) {
            for (let i = 0; i < array.length; i += batchSize) {
                yield array.slice(i, i + batchSize);
            }
        }

        async function testResourceLoading() {
            for await (const batch of batchGenerator(resources, BATCH_SIZE)) {
                await Promise.all(batch.map(url => fetchResource(url)));  // Fetch in parallel (limited)
            }
        }

        function updateResults() {
            document.getElementById('loaded-count').innerText = loaded + blocked;
            document.getElementById('waiting-count').innerText = total_resources - (loaded + blocked);
        }

        function overrideFetch() {
            /*
                Function to override original fetch to check how many resources have
                been fetched or are pending to be fetched
            */
            window.total_fetch_count = { pending: 0, completed: 0 };

            // save the original fetch function
            const originalFetch = window.fetch;
            window.fetch = function(...args) {

                // once fetch was called, add it to pending
                window.total_fetch_count.pending++;

                // apply the original fetcj
                return originalFetch.apply(this, args).then(response => {
                    // after resolving fetch, remove from pending and add to completed
                    window.total_fetch_count.pending--;
                    window.total_fetch_count.completed++;
                    return response;
                }).catch(error => {
                    // in case of an error, its resolved either way - remove from pending, add compelted
                    window.total_fetch_count.pending--;
                    window.total_fetch_count.completed++;
                    throw error;
                });
            };
        }

        overrideFetch();
        
        // start fetching on page load
        window.addEventListener('load', testResourceLoading);

    </script>
</head>
<body>
    <h1>Content Blocking Test</h1>
    <p>Fetches waiting for:<span id="waiting-count">0</span></p>
    <p>Finished resources:<span id="loaded-count">0</span></p>
</body>
</html>